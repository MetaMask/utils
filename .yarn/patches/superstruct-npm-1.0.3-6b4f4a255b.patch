diff --git a/dist/error.d.cts b/dist/error.d.cts
new file mode 100644
index 0000000000000000000000000000000000000000..bd76ed63bae2b0bb173a001ea821abcdb540d109
--- /dev/null
+++ b/dist/error.d.cts
@@ -0,0 +1,33 @@
+/**
+ * A `StructFailure` represents a single specific failure in validation.
+ */
+export declare type Failure = {
+    value: any;
+    key: any;
+    type: string;
+    refinement: string | undefined;
+    message: string;
+    explanation?: string;
+    branch: Array<any>;
+    path: Array<any>;
+};
+/**
+ * `StructError` objects are thrown (or returned) when validation fails.
+ *
+ * Validation logic is design to exit early for maximum performance. The error
+ * represents the first error encountered during validation. For more detail,
+ * the `error.failures` property is a generator function that can be run to
+ * continue validation and receive all the failures in the data.
+ */
+export declare class StructError extends TypeError {
+    value: any;
+    key: any;
+    type: string;
+    refinement: string | undefined;
+    path: Array<any>;
+    branch: Array<any>;
+    failures: () => Array<Failure>;
+    [x: string]: any;
+    constructor(failure: Failure, failures: () => Generator<Failure>);
+}
+//# sourceMappingURL=error.d.ts.map
\ No newline at end of file
diff --git a/dist/error.d.mts b/dist/error.d.mts
new file mode 100644
index 0000000000000000000000000000000000000000..bd76ed63bae2b0bb173a001ea821abcdb540d109
--- /dev/null
+++ b/dist/error.d.mts
@@ -0,0 +1,33 @@
+/**
+ * A `StructFailure` represents a single specific failure in validation.
+ */
+export declare type Failure = {
+    value: any;
+    key: any;
+    type: string;
+    refinement: string | undefined;
+    message: string;
+    explanation?: string;
+    branch: Array<any>;
+    path: Array<any>;
+};
+/**
+ * `StructError` objects are thrown (or returned) when validation fails.
+ *
+ * Validation logic is design to exit early for maximum performance. The error
+ * represents the first error encountered during validation. For more detail,
+ * the `error.failures` property is a generator function that can be run to
+ * continue validation and receive all the failures in the data.
+ */
+export declare class StructError extends TypeError {
+    value: any;
+    key: any;
+    type: string;
+    refinement: string | undefined;
+    path: Array<any>;
+    branch: Array<any>;
+    failures: () => Array<Failure>;
+    [x: string]: any;
+    constructor(failure: Failure, failures: () => Generator<Failure>);
+}
+//# sourceMappingURL=error.d.ts.map
\ No newline at end of file
diff --git a/dist/error.d.ts b/dist/error.d.ts
deleted file mode 100644
index bd76ed63bae2b0bb173a001ea821abcdb540d109..0000000000000000000000000000000000000000
--- a/dist/error.d.ts
+++ /dev/null
@@ -1,33 +0,0 @@
-/**
- * A `StructFailure` represents a single specific failure in validation.
- */
-export declare type Failure = {
-    value: any;
-    key: any;
-    type: string;
-    refinement: string | undefined;
-    message: string;
-    explanation?: string;
-    branch: Array<any>;
-    path: Array<any>;
-};
-/**
- * `StructError` objects are thrown (or returned) when validation fails.
- *
- * Validation logic is design to exit early for maximum performance. The error
- * represents the first error encountered during validation. For more detail,
- * the `error.failures` property is a generator function that can be run to
- * continue validation and receive all the failures in the data.
- */
-export declare class StructError extends TypeError {
-    value: any;
-    key: any;
-    type: string;
-    refinement: string | undefined;
-    path: Array<any>;
-    branch: Array<any>;
-    failures: () => Array<Failure>;
-    [x: string]: any;
-    constructor(failure: Failure, failures: () => Generator<Failure>);
-}
-//# sourceMappingURL=error.d.ts.map
\ No newline at end of file
diff --git a/dist/index.d.cts b/dist/index.d.cts
new file mode 100644
index 0000000000000000000000000000000000000000..0ce42ddc406e4dc8573f0ad98e25d3f3ac552173
--- /dev/null
+++ b/dist/index.d.cts
@@ -0,0 +1,7 @@
+export * from './error.cjs';
+export * from './struct.cjs';
+export * from './structs/coercions.cjs';
+export * from './structs/refinements.cjs';
+export * from './structs/types.cjs';
+export * from './structs/utilities.cjs';
+//# sourceMappingURL=index.d.ts.map
diff --git a/dist/index.d.mts b/dist/index.d.mts
new file mode 100644
index 0000000000000000000000000000000000000000..d5e3f9cef4f1d3fd2ba4fa2c85c27439fa7dbfbc
--- /dev/null
+++ b/dist/index.d.mts
@@ -0,0 +1,7 @@
+export * from './error.mjs';
+export * from './struct.mjs';
+export * from './structs/coercions.mjs';
+export * from './structs/refinements.mjs';
+export * from './structs/types.mjs';
+export * from './structs/utilities.mjs';
+//# sourceMappingURL=index.d.ts.map
diff --git a/dist/index.d.ts b/dist/index.d.ts
deleted file mode 100644
index ef1242342faee809ac4106cf453c0bc27e38d4ad..0000000000000000000000000000000000000000
--- a/dist/index.d.ts
+++ /dev/null
@@ -1,7 +0,0 @@
-export * from './error';
-export * from './struct';
-export * from './structs/coercions';
-export * from './structs/refinements';
-export * from './structs/types';
-export * from './structs/utilities';
-//# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/dist/struct.d.cts b/dist/struct.d.cts
new file mode 100644
index 0000000000000000000000000000000000000000..ccb2632e60e185f9d8eacc8ede11d7a18badd4f9
--- /dev/null
+++ b/dist/struct.d.cts
@@ -0,0 +1,112 @@
+import { StructSchema } from './utils.cjs';
+import { StructError, Failure } from './error.cjs';
+/**
+ * `Struct` objects encapsulate the validation logic for a specific type of
+ * values. Once constructed, you use the `assert`, `is` or `validate` helpers to
+ * validate unknown input data against the struct.
+ */
+export declare class Struct<T = unknown, S = unknown> {
+  readonly TYPE: T;
+  type: string;
+  schema: S;
+  coercer: (value: unknown, context: Context) => unknown;
+  validator: (value: unknown, context: Context) => Iterable<Failure>;
+  refiner: (value: T, context: Context) => Iterable<Failure>;
+  entries: (value: unknown, context: Context) => Iterable<[string | number, unknown, Struct<any> | Struct<never>]>;
+  constructor(props: {
+    type: string;
+    schema: S;
+    coercer?: Coercer;
+    validator?: Validator;
+    refiner?: Refiner<T>;
+    entries?: Struct<T, S>['entries'];
+  });
+  /**
+   * Assert that a value passes the struct's validation, throwing if it doesn't.
+   */
+  assert(value: unknown, message?: string): asserts value is T;
+  /**
+   * Create a value with the struct's coercion logic, then validate it.
+   */
+  create(value: unknown, message?: string): T;
+  /**
+   * Check if a value passes the struct's validation.
+   */
+  is(value: unknown): value is T;
+  /**
+   * Mask a value, coercing and validating it, but returning only the subset of
+   * properties defined by the struct's schema.
+   */
+  mask(value: unknown, message?: string): T;
+  /**
+   * Validate a value with the struct's validation logic, returning a tuple
+   * representing the result.
+   *
+   * You may optionally pass `true` for the `withCoercion` argument to coerce
+   * the value before attempting to validate it. If you do, the result will
+   * contain the coerced result when successful.
+   */
+  validate(value: unknown, options?: {
+    coerce?: boolean;
+    message?: string;
+  }): [StructError, undefined] | [undefined, T];
+}
+/**
+ * Assert that a value passes a struct, throwing if it doesn't.
+ */
+export declare function assert<T, S>(value: unknown, struct: Struct<T, S>, message?: string): asserts value is T;
+/**
+ * Create a value with the coercion logic of struct and validate it.
+ */
+export declare function create<T, S>(value: unknown, struct: Struct<T, S>, message?: string): T;
+/**
+ * Mask a value, returning only the subset of properties defined by a struct.
+ */
+export declare function mask<T, S>(value: unknown, struct: Struct<T, S>, message?: string): T;
+/**
+ * Check if a value passes a struct.
+ */
+export declare function is<T, S>(value: unknown, struct: Struct<T, S>): value is T;
+/**
+ * Validate a value against a struct, returning an error if invalid, or the
+ * value (with potential coercion) if valid.
+ */
+export declare function validate<T, S>(value: unknown, struct: Struct<T, S>, options?: {
+  coerce?: boolean;
+  mask?: boolean;
+  message?: string;
+}): [StructError, undefined] | [undefined, T];
+/**
+ * A `Context` contains information about the current location of the
+ * validation inside the initial input value.
+ */
+export declare type Context = {
+  branch: Array<any>;
+  path: Array<any>;
+};
+/**
+ * A type utility to extract the type from a `Struct` class.
+ */
+export declare type Infer<T extends Struct<any, any>> = T['TYPE'];
+/**
+ * A type utility to describe that a struct represents a TypeScript type.
+ */
+export declare type Describe<T> = Struct<T, StructSchema<T>>;
+/**
+ * A `Result` is returned from validation functions.
+ */
+export declare type Result = boolean | string | Partial<Failure> | Iterable<boolean | string | Partial<Failure>>;
+/**
+ * A `Coercer` takes an unknown value and optionally coerces it.
+ */
+export declare type Coercer<T = unknown> = (value: T, context: Context) => unknown;
+/**
+ * A `Validator` takes an unknown value and validates it.
+ */
+export declare type Validator = (value: unknown, context: Context) => Result;
+/**
+ * A `Refiner` takes a value of a known type and validates it against a further
+ * constraint.
+ */
+export declare type Refiner<T> = (value: T, context: Context) => Result;
+//# sourceMappingURL=struct.d.ts.map
diff --git a/dist/struct.d.mts b/dist/struct.d.mts
new file mode 100644
index 0000000000000000000000000000000000000000..b34b3e438dcdde374fc9b0491e86cde422980af5
--- /dev/null
+++ b/dist/struct.d.mts
@@ -0,0 +1,112 @@
+import { StructSchema } from './utils.mjs';
+import { StructError, Failure } from './error.mjs';
+/**
+ * `Struct` objects encapsulate the validation logic for a specific type of
+ * values. Once constructed, you use the `assert`, `is` or `validate` helpers to
+ * validate unknown input data against the struct.
+ */
+export declare class Struct<T = unknown, S = unknown> {
+  readonly TYPE: T;
+  type: string;
+  schema: S;
+  coercer: (value: unknown, context: Context) => unknown;
+  validator: (value: unknown, context: Context) => Iterable<Failure>;
+  refiner: (value: T, context: Context) => Iterable<Failure>;
+  entries: (value: unknown, context: Context) => Iterable<[string | number, unknown, Struct<any> | Struct<never>]>;
+  constructor(props: {
+    type: string;
+    schema: S;
+    coercer?: Coercer;
+    validator?: Validator;
+    refiner?: Refiner<T>;
+    entries?: Struct<T, S>['entries'];
+  });
+  /**
+   * Assert that a value passes the struct's validation, throwing if it doesn't.
+   */
+  assert(value: unknown, message?: string): asserts value is T;
+  /**
+   * Create a value with the struct's coercion logic, then validate it.
+   */
+  create(value: unknown, message?: string): T;
+  /**
+   * Check if a value passes the struct's validation.
+   */
+  is(value: unknown): value is T;
+  /**
+   * Mask a value, coercing and validating it, but returning only the subset of
+   * properties defined by the struct's schema.
+   */
+  mask(value: unknown, message?: string): T;
+  /**
+   * Validate a value with the struct's validation logic, returning a tuple
+   * representing the result.
+   *
+   * You may optionally pass `true` for the `withCoercion` argument to coerce
+   * the value before attempting to validate it. If you do, the result will
+   * contain the coerced result when successful.
+   */
+  validate(value: unknown, options?: {
+    coerce?: boolean;
+    message?: string;
+  }): [StructError, undefined] | [undefined, T];
+}
+/**
+ * Assert that a value passes a struct, throwing if it doesn't.
+ */
+export declare function assert<T, S>(value: unknown, struct: Struct<T, S>, message?: string): asserts value is T;
+/**
+ * Create a value with the coercion logic of struct and validate it.
+ */
+export declare function create<T, S>(value: unknown, struct: Struct<T, S>, message?: string): T;
+/**
+ * Mask a value, returning only the subset of properties defined by a struct.
+ */
+export declare function mask<T, S>(value: unknown, struct: Struct<T, S>, message?: string): T;
+/**
+ * Check if a value passes a struct.
+ */
+export declare function is<T, S>(value: unknown, struct: Struct<T, S>): value is T;
+/**
+ * Validate a value against a struct, returning an error if invalid, or the
+ * value (with potential coercion) if valid.
+ */
+export declare function validate<T, S>(value: unknown, struct: Struct<T, S>, options?: {
+  coerce?: boolean;
+  mask?: boolean;
+  message?: string;
+}): [StructError, undefined] | [undefined, T];
+/**
+ * A `Context` contains information about the current location of the
+ * validation inside the initial input value.
+ */
+export declare type Context = {
+  branch: Array<any>;
+  path: Array<any>;
+};
+/**
+ * A type utility to extract the type from a `Struct` class.
+ */
+export declare type Infer<T extends Struct<any, any>> = T['TYPE'];
+/**
+ * A type utility to describe that a struct represents a TypeScript type.
+ */
+export declare type Describe<T> = Struct<T, StructSchema<T>>;
+/**
+ * A `Result` is returned from validation functions.
+ */
+export declare type Result = boolean | string | Partial<Failure> | Iterable<boolean | string | Partial<Failure>>;
+/**
+ * A `Coercer` takes an unknown value and optionally coerces it.
+ */
+export declare type Coercer<T = unknown> = (value: T, context: Context) => unknown;
+/**
+ * A `Validator` takes an unknown value and validates it.
+ */
+export declare type Validator = (value: unknown, context: Context) => Result;
+/**
+ * A `Refiner` takes a value of a known type and validates it against a further
+ * constraint.
+ */
+export declare type Refiner<T> = (value: T, context: Context) => Result;
+//# sourceMappingURL=struct.d.ts.map
diff --git a/dist/struct.d.ts b/dist/struct.d.ts
deleted file mode 100644
index 80be1899f2e9fe905c23573dbfd19eefc26b7432..0000000000000000000000000000000000000000
--- a/dist/struct.d.ts
+++ /dev/null
@@ -1,112 +0,0 @@
-import { StructSchema } from './utils';
-import { StructError, Failure } from './error';
-/**
- * `Struct` objects encapsulate the validation logic for a specific type of
- * values. Once constructed, you use the `assert`, `is` or `validate` helpers to
- * validate unknown input data against the struct.
- */
-export declare class Struct<T = unknown, S = unknown> {
-    readonly TYPE: T;
-    type: string;
-    schema: S;
-    coercer: (value: unknown, context: Context) => unknown;
-    validator: (value: unknown, context: Context) => Iterable<Failure>;
-    refiner: (value: T, context: Context) => Iterable<Failure>;
-    entries: (value: unknown, context: Context) => Iterable<[string | number, unknown, Struct<any> | Struct<never>]>;
-    constructor(props: {
-        type: string;
-        schema: S;
-        coercer?: Coercer;
-        validator?: Validator;
-        refiner?: Refiner<T>;
-        entries?: Struct<T, S>['entries'];
-    });
-    /**
-     * Assert that a value passes the struct's validation, throwing if it doesn't.
-     */
-    assert(value: unknown, message?: string): asserts value is T;
-    /**
-     * Create a value with the struct's coercion logic, then validate it.
-     */
-    create(value: unknown, message?: string): T;
-    /**
-     * Check if a value passes the struct's validation.
-     */
-    is(value: unknown): value is T;
-    /**
-     * Mask a value, coercing and validating it, but returning only the subset of
-     * properties defined by the struct's schema.
-     */
-    mask(value: unknown, message?: string): T;
-    /**
-     * Validate a value with the struct's validation logic, returning a tuple
-     * representing the result.
-     *
-     * You may optionally pass `true` for the `withCoercion` argument to coerce
-     * the value before attempting to validate it. If you do, the result will
-     * contain the coerced result when successful.
-     */
-    validate(value: unknown, options?: {
-        coerce?: boolean;
-        message?: string;
-    }): [StructError, undefined] | [undefined, T];
-}
-/**
- * Assert that a value passes a struct, throwing if it doesn't.
- */
-export declare function assert<T, S>(value: unknown, struct: Struct<T, S>, message?: string): asserts value is T;
-/**
- * Create a value with the coercion logic of struct and validate it.
- */
-export declare function create<T, S>(value: unknown, struct: Struct<T, S>, message?: string): T;
-/**
- * Mask a value, returning only the subset of properties defined by a struct.
- */
-export declare function mask<T, S>(value: unknown, struct: Struct<T, S>, message?: string): T;
-/**
- * Check if a value passes a struct.
- */
-export declare function is<T, S>(value: unknown, struct: Struct<T, S>): value is T;
-/**
- * Validate a value against a struct, returning an error if invalid, or the
- * value (with potential coercion) if valid.
- */
-export declare function validate<T, S>(value: unknown, struct: Struct<T, S>, options?: {
-    coerce?: boolean;
-    mask?: boolean;
-    message?: string;
-}): [StructError, undefined] | [undefined, T];
-/**
- * A `Context` contains information about the current location of the
- * validation inside the initial input value.
- */
-export declare type Context = {
-    branch: Array<any>;
-    path: Array<any>;
-};
-/**
- * A type utility to extract the type from a `Struct` class.
- */
-export declare type Infer<T extends Struct<any, any>> = T['TYPE'];
-/**
- * A type utility to describe that a struct represents a TypeScript type.
- */
-export declare type Describe<T> = Struct<T, StructSchema<T>>;
-/**
- * A `Result` is returned from validation functions.
- */
-export declare type Result = boolean | string | Partial<Failure> | Iterable<boolean | string | Partial<Failure>>;
-/**
- * A `Coercer` takes an unknown value and optionally coerces it.
- */
-export declare type Coercer<T = unknown> = (value: T, context: Context) => unknown;
-/**
- * A `Validator` takes an unknown value and validates it.
- */
-export declare type Validator = (value: unknown, context: Context) => Result;
-/**
- * A `Refiner` takes a value of a known type and validates it against a further
- * constraint.
- */
-export declare type Refiner<T> = (value: T, context: Context) => Result;
-//# sourceMappingURL=struct.d.ts.map
\ No newline at end of file
diff --git a/dist/structs/coercions.d.cts b/dist/structs/coercions.d.cts
new file mode 100644
index 0000000000000000000000000000000000000000..2b71416b535029a8dd2c3a85a9a921a85943ba6a
--- /dev/null
+++ b/dist/structs/coercions.d.cts
@@ -0,0 +1,29 @@
+import { Struct, Coercer } from '../struct.cjs';
+/**
+ * Augment a `Struct` to add an additional coercion step to its input.
+ *
+ * This allows you to transform input data before validating it, to increase the
+ * likelihood that it passes validation—for example for default values, parsing
+ * different formats, etc.
+ *
+ * Note: You must use `create(value, Struct)` on the value to have the coercion
+ * take effect! Using simply `assert()` or `is()` will not use coercion.
+ */
+export declare function coerce<T, S, C>(struct: Struct<T, S>, condition: Struct<C, any>, coercer: Coercer<C>): Struct<T, S>;
+/**
+ * Augment a struct to replace `undefined` values with a default.
+ *
+ * Note: You must use `create(value, Struct)` on the value to have the coercion
+ * take effect! Using simply `assert()` or `is()` will not use coercion.
+ */
+export declare function defaulted<T, S>(struct: Struct<T, S>, fallback: any, options?: {
+  strict?: boolean;
+}): Struct<T, S>;
+/**
+ * Augment a struct to trim string inputs.
+ *
+ * Note: You must use `create(value, Struct)` on the value to have the coercion
+ * take effect! Using simply `assert()` or `is()` will not use coercion.
+ */
+export declare function trimmed<T, S>(struct: Struct<T, S>): Struct<T, S>;
+//# sourceMappingURL=coercions.d.ts.map
diff --git a/dist/structs/coercions.d.mts b/dist/structs/coercions.d.mts
new file mode 100644
index 0000000000000000000000000000000000000000..3866a5928aacad8d340e7f107e94f98cba4f5ed0
--- /dev/null
+++ b/dist/structs/coercions.d.mts
@@ -0,0 +1,29 @@
+import { Struct, Coercer } from '../struct.mjs';
+/**
+ * Augment a `Struct` to add an additional coercion step to its input.
+ *
+ * This allows you to transform input data before validating it, to increase the
+ * likelihood that it passes validation—for example for default values, parsing
+ * different formats, etc.
+ *
+ * Note: You must use `create(value, Struct)` on the value to have the coercion
+ * take effect! Using simply `assert()` or `is()` will not use coercion.
+ */
+export declare function coerce<T, S, C>(struct: Struct<T, S>, condition: Struct<C, any>, coercer: Coercer<C>): Struct<T, S>;
+/**
+ * Augment a struct to replace `undefined` values with a default.
+ *
+ * Note: You must use `create(value, Struct)` on the value to have the coercion
+ * take effect! Using simply `assert()` or `is()` will not use coercion.
+ */
+export declare function defaulted<T, S>(struct: Struct<T, S>, fallback: any, options?: {
+  strict?: boolean;
+}): Struct<T, S>;
+/**
+ * Augment a struct to trim string inputs.
+ *
+ * Note: You must use `create(value, Struct)` on the value to have the coercion
+ * take effect! Using simply `assert()` or `is()` will not use coercion.
+ */
+export declare function trimmed<T, S>(struct: Struct<T, S>): Struct<T, S>;
+//# sourceMappingURL=coercions.d.ts.map
diff --git a/dist/structs/coercions.d.ts b/dist/structs/coercions.d.ts
deleted file mode 100644
index f8e8c2abe181b30ac724e0d49db8651645ef4182..0000000000000000000000000000000000000000
--- a/dist/structs/coercions.d.ts
+++ /dev/null
@@ -1,29 +0,0 @@
-import { Struct, Coercer } from '../struct';
-/**
- * Augment a `Struct` to add an additional coercion step to its input.
- *
- * This allows you to transform input data before validating it, to increase the
- * likelihood that it passes validation—for example for default values, parsing
- * different formats, etc.
- *
- * Note: You must use `create(value, Struct)` on the value to have the coercion
- * take effect! Using simply `assert()` or `is()` will not use coercion.
- */
-export declare function coerce<T, S, C>(struct: Struct<T, S>, condition: Struct<C, any>, coercer: Coercer<C>): Struct<T, S>;
-/**
- * Augment a struct to replace `undefined` values with a default.
- *
- * Note: You must use `create(value, Struct)` on the value to have the coercion
- * take effect! Using simply `assert()` or `is()` will not use coercion.
- */
-export declare function defaulted<T, S>(struct: Struct<T, S>, fallback: any, options?: {
-    strict?: boolean;
-}): Struct<T, S>;
-/**
- * Augment a struct to trim string inputs.
- *
- * Note: You must use `create(value, Struct)` on the value to have the coercion
- * take effect! Using simply `assert()` or `is()` will not use coercion.
- */
-export declare function trimmed<T, S>(struct: Struct<T, S>): Struct<T, S>;
-//# sourceMappingURL=coercions.d.ts.map
\ No newline at end of file
diff --git a/dist/structs/refinements.d.cts b/dist/structs/refinements.d.cts
new file mode 100644
index 0000000000000000000000000000000000000000..3d1045d1aac017ed85413365d36e20f5222a030c
--- /dev/null
+++ b/dist/structs/refinements.d.cts
@@ -0,0 +1,38 @@
+import { Struct, Refiner } from '../struct.cjs';
+/**
+ * Ensure that a string, array, map, or set is empty.
+ */
+export declare function empty<T extends string | any[] | Map<any, any> | Set<any>, S extends any>(struct: Struct<T, S>): Struct<T, S>;
+/**
+ * Ensure that a number or date is below a threshold.
+ */
+export declare function max<T extends number | Date, S extends any>(struct: Struct<T, S>, threshold: T, options?: {
+  exclusive?: boolean;
+}): Struct<T, S>;
+/**
+ * Ensure that a number or date is above a threshold.
+ */
+export declare function min<T extends number | Date, S extends any>(struct: Struct<T, S>, threshold: T, options?: {
+  exclusive?: boolean;
+}): Struct<T, S>;
+/**
+ * Ensure that a string, array, map or set is not empty.
+ */
+export declare function nonempty<T extends string | any[] | Map<any, any> | Set<any>, S extends any>(struct: Struct<T, S>): Struct<T, S>;
+/**
+ * Ensure that a string matches a regular expression.
+ */
+export declare function pattern<T extends string, S extends any>(struct: Struct<T, S>, regexp: RegExp): Struct<T, S>;
+/**
+ * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.
+ */
+export declare function size<T extends string | number | Date | any[] | Map<any, any> | Set<any>, S extends any>(struct: Struct<T, S>, min: number, max?: number): Struct<T, S>;
+/**
+ * Augment a `Struct` to add an additional refinement to the validation.
+ *
+ * The refiner function is guaranteed to receive a value of the struct's type,
+ * because the struct's existing validation will already have passed. This
+ * allows you to layer additional validation on top of existing structs.
+ */
+export declare function refine<T, S>(struct: Struct<T, S>, name: string, refiner: Refiner<T>): Struct<T, S>;
+//# sourceMappingURL=refinements.d.ts.map
diff --git a/dist/structs/refinements.d.mts b/dist/structs/refinements.d.mts
new file mode 100644
index 0000000000000000000000000000000000000000..4c034b3eca9190a9480b15eb36dbb19edfe8e6f5
--- /dev/null
+++ b/dist/structs/refinements.d.mts
@@ -0,0 +1,38 @@
+import { Struct, Refiner } from '../struct.mjs';
+/**
+ * Ensure that a string, array, map, or set is empty.
+ */
+export declare function empty<T extends string | any[] | Map<any, any> | Set<any>, S extends any>(struct: Struct<T, S>): Struct<T, S>;
+/**
+ * Ensure that a number or date is below a threshold.
+ */
+export declare function max<T extends number | Date, S extends any>(struct: Struct<T, S>, threshold: T, options?: {
+  exclusive?: boolean;
+}): Struct<T, S>;
+/**
+ * Ensure that a number or date is above a threshold.
+ */
+export declare function min<T extends number | Date, S extends any>(struct: Struct<T, S>, threshold: T, options?: {
+  exclusive?: boolean;
+}): Struct<T, S>;
+/**
+ * Ensure that a string, array, map or set is not empty.
+ */
+export declare function nonempty<T extends string | any[] | Map<any, any> | Set<any>, S extends any>(struct: Struct<T, S>): Struct<T, S>;
+/**
+ * Ensure that a string matches a regular expression.
+ */
+export declare function pattern<T extends string, S extends any>(struct: Struct<T, S>, regexp: RegExp): Struct<T, S>;
+/**
+ * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.
+ */
+export declare function size<T extends string | number | Date | any[] | Map<any, any> | Set<any>, S extends any>(struct: Struct<T, S>, min: number, max?: number): Struct<T, S>;
+/**
+ * Augment a `Struct` to add an additional refinement to the validation.
+ *
+ * The refiner function is guaranteed to receive a value of the struct's type,
+ * because the struct's existing validation will already have passed. This
+ * allows you to layer additional validation on top of existing structs.
+ */
+export declare function refine<T, S>(struct: Struct<T, S>, name: string, refiner: Refiner<T>): Struct<T, S>;
+//# sourceMappingURL=refinements.d.ts.map
diff --git a/dist/structs/refinements.d.ts b/dist/structs/refinements.d.ts
deleted file mode 100644
index af3cd92e03439869172f236537693f55fc4c7d9a..0000000000000000000000000000000000000000
--- a/dist/structs/refinements.d.ts
+++ /dev/null
@@ -1,38 +0,0 @@
-import { Struct, Refiner } from '../struct';
-/**
- * Ensure that a string, array, map, or set is empty.
- */
-export declare function empty<T extends string | any[] | Map<any, any> | Set<any>, S extends any>(struct: Struct<T, S>): Struct<T, S>;
-/**
- * Ensure that a number or date is below a threshold.
- */
-export declare function max<T extends number | Date, S extends any>(struct: Struct<T, S>, threshold: T, options?: {
-    exclusive?: boolean;
-}): Struct<T, S>;
-/**
- * Ensure that a number or date is above a threshold.
- */
-export declare function min<T extends number | Date, S extends any>(struct: Struct<T, S>, threshold: T, options?: {
-    exclusive?: boolean;
-}): Struct<T, S>;
-/**
- * Ensure that a string, array, map or set is not empty.
- */
-export declare function nonempty<T extends string | any[] | Map<any, any> | Set<any>, S extends any>(struct: Struct<T, S>): Struct<T, S>;
-/**
- * Ensure that a string matches a regular expression.
- */
-export declare function pattern<T extends string, S extends any>(struct: Struct<T, S>, regexp: RegExp): Struct<T, S>;
-/**
- * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.
- */
-export declare function size<T extends string | number | Date | any[] | Map<any, any> | Set<any>, S extends any>(struct: Struct<T, S>, min: number, max?: number): Struct<T, S>;
-/**
- * Augment a `Struct` to add an additional refinement to the validation.
- *
- * The refiner function is guaranteed to receive a value of the struct's type,
- * because the struct's existing validation will already have passed. This
- * allows you to layer additional validation on top of existing structs.
- */
-export declare function refine<T, S>(struct: Struct<T, S>, name: string, refiner: Refiner<T>): Struct<T, S>;
-//# sourceMappingURL=refinements.d.ts.map
\ No newline at end of file
diff --git a/dist/structs/types.d.cts b/dist/structs/types.d.cts
new file mode 100644
index 0000000000000000000000000000000000000000..fab2f57527fa526b23a2ce7cc90f49532992f48c
--- /dev/null
+++ b/dist/structs/types.d.cts
@@ -0,0 +1,142 @@
+import { Infer, Struct } from '../struct.cjs';
+import { ObjectSchema, ObjectType, AnyStruct, InferStructTuple, UnionToIntersection } from '../utils.cjs';
+/**
+ * Ensure that any value passes validation.
+ */
+export declare function any(): Struct<any, null>;
+/**
+ * Ensure that a value is an array and that its elements are of a specific type.
+ *
+ * Note: If you omit the element struct, the arrays elements will not be
+ * iterated at all. This can be helpful for cases where performance is critical,
+ * and it is preferred to using `array(any())`.
+ */
+export declare function array<T extends Struct<any>>(Element: T): Struct<Infer<T>[], T>;
+export declare function array(): Struct<unknown[], undefined>;
+/**
+ * Ensure that a value is a bigint.
+ */
+export declare function bigint(): Struct<bigint, null>;
+/**
+ * Ensure that a value is a boolean.
+ */
+export declare function boolean(): Struct<boolean, null>;
+/**
+ * Ensure that a value is a valid `Date`.
+ *
+ * Note: this also ensures that the value is *not* an invalid `Date` object,
+ * which can occur when parsing a date fails but still returns a `Date`.
+ */
+export declare function date(): Struct<Date, null>;
+/**
+ * Ensure that a value is one of a set of potential values.
+ *
+ * Note: after creating the struct, you can access the definition of the
+ * potential values as `struct.schema`.
+ */
+export declare function enums<U extends number, T extends readonly U[]>(values: T): Struct<T[number], {
+  [K in T[number]]: K;
+}>;
+export declare function enums<U extends string, T extends readonly U[]>(values: T): Struct<T[number], {
+  [K in T[number]]: K;
+}>;
+/**
+ * Ensure that a value is a function.
+ */
+export declare function func(): Struct<Function, null>;
+/**
+ * Ensure that a value is an instance of a specific class.
+ */
+export declare function instance<T extends {
+  new(...args: any): any;
+}>(Class: T): Struct<InstanceType<T>, null>;
+/**
+ * Ensure that a value is an integer.
+ */
+export declare function integer(): Struct<number, null>;
+/**
+ * Ensure that a value matches all of a set of types.
+ */
+export declare function intersection<A extends AnyStruct, B extends AnyStruct[]>(Structs: [A, ...B]): Struct<Infer<A> & UnionToIntersection<InferStructTuple<B>[number]>, null>;
+/**
+ * Ensure that a value is an exact value, using `===` for comparison.
+ */
+export declare function literal<T extends boolean>(constant: T): Struct<T, T>;
+export declare function literal<T extends number>(constant: T): Struct<T, T>;
+export declare function literal<T extends string>(constant: T): Struct<T, T>;
+export declare function literal<T>(constant: T): Struct<T, null>;
+/**
+ * Ensure that a value is a `Map` object, and that its keys and values are of
+ * specific types.
+ */
+export declare function map(): Struct<Map<unknown, unknown>, null>;
+export declare function map<K, V>(Key: Struct<K>, Value: Struct<V>): Struct<Map<K, V>, null>;
+/**
+ * Ensure that no value ever passes validation.
+ */
+export declare function never(): Struct<never, null>;
+/**
+ * Augment an existing struct to allow `null` values.
+ */
+export declare function nullable<T, S>(struct: Struct<T, S>): Struct<T | null, S>;
+/**
+ * Ensure that a value is a number.
+ */
+export declare function number(): Struct<number, null>;
+/**
+ * Ensure that a value is an object, that is has a known set of properties,
+ * and that its properties are of specific types.
+ *
+ * Note: Unrecognized properties will fail validation.
+ */
+export declare function object(): Struct<Record<string, unknown>, null>;
+export declare function object<S extends ObjectSchema>(schema: S): Struct<ObjectType<S>, S>;
+/**
+ * Augment a struct to allow `undefined` values.
+ */
+export declare function optional<T, S>(struct: Struct<T, S>): Struct<T | undefined, S>;
+/**
+ * Ensure that a value is an object with keys and values of specific types, but
+ * without ensuring any specific shape of properties.
+ *
+ * Like TypeScript's `Record` utility.
+ */
+export declare function record<K extends string, V>(Key: Struct<K>, Value: Struct<V>): Struct<Record<K, V>, null>;
+/**
+ * Ensure that a value is a `RegExp`.
+ *
+ * Note: this does not test the value against the regular expression! For that
+ * you need to use the `pattern()` refinement.
+ */
+export declare function regexp(): Struct<RegExp, null>;
+/**
+ * Ensure that a value is a `Set` object, and that its elements are of a
+ * specific type.
+ */
+export declare function set(): Struct<Set<unknown>, null>;
+export declare function set<T>(Element: Struct<T>): Struct<Set<T>, null>;
+/**
+ * Ensure that a value is a string.
+ */
+export declare function string(): Struct<string, null>;
+/**
+ * Ensure that a value is a tuple of a specific length, and that each of its
+ * elements is of a specific type.
+ */
+export declare function tuple<A extends AnyStruct, B extends AnyStruct[]>(Structs: [A, ...B]): Struct<[Infer<A>, ...InferStructTuple<B>], null>;
+/**
+ * Ensure that a value has a set of known properties of specific types.
+ *
+ * Note: Unrecognized properties are allowed and untouched. This is similar to
+ * how TypeScript's structural typing works.
+ */
+export declare function type<S extends ObjectSchema>(schema: S): Struct<ObjectType<S>, S>;
+/**
+ * Ensure that a value matches one of a set of types.
+ */
+export declare function union<A extends AnyStruct, B extends AnyStruct[]>(Structs: [A, ...B]): Struct<Infer<A> | InferStructTuple<B>[number], null>;
+/**
+ * Ensure that any value passes validation, without widening its type to `any`.
+ */
+export declare function unknown(): Struct<unknown, null>;
+//# sourceMappingURL=types.d.ts.map
diff --git a/dist/structs/types.d.mts b/dist/structs/types.d.mts
new file mode 100644
index 0000000000000000000000000000000000000000..0a3090aa917700d96c45a21c4f381ec7fb5d0c0c
--- /dev/null
+++ b/dist/structs/types.d.mts
@@ -0,0 +1,142 @@
+import { Infer, Struct } from '../struct.mjs';
+import { ObjectSchema, ObjectType, AnyStruct, InferStructTuple, UnionToIntersection } from '../utils.mjs';
+/**
+ * Ensure that any value passes validation.
+ */
+export declare function any(): Struct<any, null>;
+/**
+ * Ensure that a value is an array and that its elements are of a specific type.
+ *
+ * Note: If you omit the element struct, the arrays elements will not be
+ * iterated at all. This can be helpful for cases where performance is critical,
+ * and it is preferred to using `array(any())`.
+ */
+export declare function array<T extends Struct<any>>(Element: T): Struct<Infer<T>[], T>;
+export declare function array(): Struct<unknown[], undefined>;
+/**
+ * Ensure that a value is a bigint.
+ */
+export declare function bigint(): Struct<bigint, null>;
+/**
+ * Ensure that a value is a boolean.
+ */
+export declare function boolean(): Struct<boolean, null>;
+/**
+ * Ensure that a value is a valid `Date`.
+ *
+ * Note: this also ensures that the value is *not* an invalid `Date` object,
+ * which can occur when parsing a date fails but still returns a `Date`.
+ */
+export declare function date(): Struct<Date, null>;
+/**
+ * Ensure that a value is one of a set of potential values.
+ *
+ * Note: after creating the struct, you can access the definition of the
+ * potential values as `struct.schema`.
+ */
+export declare function enums<U extends number, T extends readonly U[]>(values: T): Struct<T[number], {
+  [K in T[number]]: K;
+}>;
+export declare function enums<U extends string, T extends readonly U[]>(values: T): Struct<T[number], {
+  [K in T[number]]: K;
+}>;
+/**
+ * Ensure that a value is a function.
+ */
+export declare function func(): Struct<Function, null>;
+/**
+ * Ensure that a value is an instance of a specific class.
+ */
+export declare function instance<T extends {
+  new(...args: any): any;
+}>(Class: T): Struct<InstanceType<T>, null>;
+/**
+ * Ensure that a value is an integer.
+ */
+export declare function integer(): Struct<number, null>;
+/**
+ * Ensure that a value matches all of a set of types.
+ */
+export declare function intersection<A extends AnyStruct, B extends AnyStruct[]>(Structs: [A, ...B]): Struct<Infer<A> & UnionToIntersection<InferStructTuple<B>[number]>, null>;
+/**
+ * Ensure that a value is an exact value, using `===` for comparison.
+ */
+export declare function literal<T extends boolean>(constant: T): Struct<T, T>;
+export declare function literal<T extends number>(constant: T): Struct<T, T>;
+export declare function literal<T extends string>(constant: T): Struct<T, T>;
+export declare function literal<T>(constant: T): Struct<T, null>;
+/**
+ * Ensure that a value is a `Map` object, and that its keys and values are of
+ * specific types.
+ */
+export declare function map(): Struct<Map<unknown, unknown>, null>;
+export declare function map<K, V>(Key: Struct<K>, Value: Struct<V>): Struct<Map<K, V>, null>;
+/**
+ * Ensure that no value ever passes validation.
+ */
+export declare function never(): Struct<never, null>;
+/**
+ * Augment an existing struct to allow `null` values.
+ */
+export declare function nullable<T, S>(struct: Struct<T, S>): Struct<T | null, S>;
+/**
+ * Ensure that a value is a number.
+ */
+export declare function number(): Struct<number, null>;
+/**
+ * Ensure that a value is an object, that is has a known set of properties,
+ * and that its properties are of specific types.
+ *
+ * Note: Unrecognized properties will fail validation.
+ */
+export declare function object(): Struct<Record<string, unknown>, null>;
+export declare function object<S extends ObjectSchema>(schema: S): Struct<ObjectType<S>, S>;
+/**
+ * Augment a struct to allow `undefined` values.
+ */
+export declare function optional<T, S>(struct: Struct<T, S>): Struct<T | undefined, S>;
+/**
+ * Ensure that a value is an object with keys and values of specific types, but
+ * without ensuring any specific shape of properties.
+ *
+ * Like TypeScript's `Record` utility.
+ */
+export declare function record<K extends string, V>(Key: Struct<K>, Value: Struct<V>): Struct<Record<K, V>, null>;
+/**
+ * Ensure that a value is a `RegExp`.
+ *
+ * Note: this does not test the value against the regular expression! For that
+ * you need to use the `pattern()` refinement.
+ */
+export declare function regexp(): Struct<RegExp, null>;
+/**
+ * Ensure that a value is a `Set` object, and that its elements are of a
+ * specific type.
+ */
+export declare function set(): Struct<Set<unknown>, null>;
+export declare function set<T>(Element: Struct<T>): Struct<Set<T>, null>;
+/**
+ * Ensure that a value is a string.
+ */
+export declare function string(): Struct<string, null>;
+/**
+ * Ensure that a value is a tuple of a specific length, and that each of its
+ * elements is of a specific type.
+ */
+export declare function tuple<A extends AnyStruct, B extends AnyStruct[]>(Structs: [A, ...B]): Struct<[Infer<A>, ...InferStructTuple<B>], null>;
+/**
+ * Ensure that a value has a set of known properties of specific types.
+ *
+ * Note: Unrecognized properties are allowed and untouched. This is similar to
+ * how TypeScript's structural typing works.
+ */
+export declare function type<S extends ObjectSchema>(schema: S): Struct<ObjectType<S>, S>;
+/**
+ * Ensure that a value matches one of a set of types.
+ */
+export declare function union<A extends AnyStruct, B extends AnyStruct[]>(Structs: [A, ...B]): Struct<Infer<A> | InferStructTuple<B>[number], null>;
+/**
+ * Ensure that any value passes validation, without widening its type to `any`.
+ */
+export declare function unknown(): Struct<unknown, null>;
+//# sourceMappingURL=types.d.ts.map
diff --git a/dist/structs/types.d.ts b/dist/structs/types.d.ts
deleted file mode 100644
index 0b15dc8b6f685c4f7fb8eede65f3f557e6532d55..0000000000000000000000000000000000000000
--- a/dist/structs/types.d.ts
+++ /dev/null
@@ -1,142 +0,0 @@
-import { Infer, Struct } from '../struct';
-import { ObjectSchema, ObjectType, AnyStruct, InferStructTuple, UnionToIntersection } from '../utils';
-/**
- * Ensure that any value passes validation.
- */
-export declare function any(): Struct<any, null>;
-/**
- * Ensure that a value is an array and that its elements are of a specific type.
- *
- * Note: If you omit the element struct, the arrays elements will not be
- * iterated at all. This can be helpful for cases where performance is critical,
- * and it is preferred to using `array(any())`.
- */
-export declare function array<T extends Struct<any>>(Element: T): Struct<Infer<T>[], T>;
-export declare function array(): Struct<unknown[], undefined>;
-/**
- * Ensure that a value is a bigint.
- */
-export declare function bigint(): Struct<bigint, null>;
-/**
- * Ensure that a value is a boolean.
- */
-export declare function boolean(): Struct<boolean, null>;
-/**
- * Ensure that a value is a valid `Date`.
- *
- * Note: this also ensures that the value is *not* an invalid `Date` object,
- * which can occur when parsing a date fails but still returns a `Date`.
- */
-export declare function date(): Struct<Date, null>;
-/**
- * Ensure that a value is one of a set of potential values.
- *
- * Note: after creating the struct, you can access the definition of the
- * potential values as `struct.schema`.
- */
-export declare function enums<U extends number, T extends readonly U[]>(values: T): Struct<T[number], {
-    [K in T[number]]: K;
-}>;
-export declare function enums<U extends string, T extends readonly U[]>(values: T): Struct<T[number], {
-    [K in T[number]]: K;
-}>;
-/**
- * Ensure that a value is a function.
- */
-export declare function func(): Struct<Function, null>;
-/**
- * Ensure that a value is an instance of a specific class.
- */
-export declare function instance<T extends {
-    new (...args: any): any;
-}>(Class: T): Struct<InstanceType<T>, null>;
-/**
- * Ensure that a value is an integer.
- */
-export declare function integer(): Struct<number, null>;
-/**
- * Ensure that a value matches all of a set of types.
- */
-export declare function intersection<A extends AnyStruct, B extends AnyStruct[]>(Structs: [A, ...B]): Struct<Infer<A> & UnionToIntersection<InferStructTuple<B>[number]>, null>;
-/**
- * Ensure that a value is an exact value, using `===` for comparison.
- */
-export declare function literal<T extends boolean>(constant: T): Struct<T, T>;
-export declare function literal<T extends number>(constant: T): Struct<T, T>;
-export declare function literal<T extends string>(constant: T): Struct<T, T>;
-export declare function literal<T>(constant: T): Struct<T, null>;
-/**
- * Ensure that a value is a `Map` object, and that its keys and values are of
- * specific types.
- */
-export declare function map(): Struct<Map<unknown, unknown>, null>;
-export declare function map<K, V>(Key: Struct<K>, Value: Struct<V>): Struct<Map<K, V>, null>;
-/**
- * Ensure that no value ever passes validation.
- */
-export declare function never(): Struct<never, null>;
-/**
- * Augment an existing struct to allow `null` values.
- */
-export declare function nullable<T, S>(struct: Struct<T, S>): Struct<T | null, S>;
-/**
- * Ensure that a value is a number.
- */
-export declare function number(): Struct<number, null>;
-/**
- * Ensure that a value is an object, that is has a known set of properties,
- * and that its properties are of specific types.
- *
- * Note: Unrecognized properties will fail validation.
- */
-export declare function object(): Struct<Record<string, unknown>, null>;
-export declare function object<S extends ObjectSchema>(schema: S): Struct<ObjectType<S>, S>;
-/**
- * Augment a struct to allow `undefined` values.
- */
-export declare function optional<T, S>(struct: Struct<T, S>): Struct<T | undefined, S>;
-/**
- * Ensure that a value is an object with keys and values of specific types, but
- * without ensuring any specific shape of properties.
- *
- * Like TypeScript's `Record` utility.
- */
-export declare function record<K extends string, V>(Key: Struct<K>, Value: Struct<V>): Struct<Record<K, V>, null>;
-/**
- * Ensure that a value is a `RegExp`.
- *
- * Note: this does not test the value against the regular expression! For that
- * you need to use the `pattern()` refinement.
- */
-export declare function regexp(): Struct<RegExp, null>;
-/**
- * Ensure that a value is a `Set` object, and that its elements are of a
- * specific type.
- */
-export declare function set(): Struct<Set<unknown>, null>;
-export declare function set<T>(Element: Struct<T>): Struct<Set<T>, null>;
-/**
- * Ensure that a value is a string.
- */
-export declare function string(): Struct<string, null>;
-/**
- * Ensure that a value is a tuple of a specific length, and that each of its
- * elements is of a specific type.
- */
-export declare function tuple<A extends AnyStruct, B extends AnyStruct[]>(Structs: [A, ...B]): Struct<[Infer<A>, ...InferStructTuple<B>], null>;
-/**
- * Ensure that a value has a set of known properties of specific types.
- *
- * Note: Unrecognized properties are allowed and untouched. This is similar to
- * how TypeScript's structural typing works.
- */
-export declare function type<S extends ObjectSchema>(schema: S): Struct<ObjectType<S>, S>;
-/**
- * Ensure that a value matches one of a set of types.
- */
-export declare function union<A extends AnyStruct, B extends AnyStruct[]>(Structs: [A, ...B]): Struct<Infer<A> | InferStructTuple<B>[number], null>;
-/**
- * Ensure that any value passes validation, without widening its type to `any`.
- */
-export declare function unknown(): Struct<unknown, null>;
-//# sourceMappingURL=types.d.ts.map
\ No newline at end of file
diff --git a/dist/structs/utilities.d.cts b/dist/structs/utilities.d.cts
new file mode 100644
index 0000000000000000000000000000000000000000..053ef730dab1323295cef9f4b244e6e9b3f44f5a
--- /dev/null
+++ b/dist/structs/utilities.d.cts
@@ -0,0 +1,66 @@
+import { Struct, Context, Validator } from '../struct.cjs';
+import { ObjectSchema, Assign, ObjectType, PartialObjectSchema } from '../utils.cjs';
+/**
+ * Create a new struct that combines the properties properties from multiple
+ * object or type structs. Its return type will match the first parameter's type.
+ *
+ * Like JavaScript's `Object.assign` utility.
+ */
+export declare function assign<A extends ObjectSchema, B extends ObjectSchema>(A: Struct<ObjectType<A>, A>, B: Struct<ObjectType<B>, B>): Struct<ObjectType<Assign<A, B>>, Assign<A, B>>;
+export declare function assign<A extends ObjectSchema, B extends ObjectSchema, C extends ObjectSchema>(A: Struct<ObjectType<A>, A>, B: Struct<ObjectType<B>, B>, C: Struct<ObjectType<C>, C>): Struct<ObjectType<Assign<Assign<A, B>, C>>, Assign<Assign<A, B>, C>>;
+export declare function assign<A extends ObjectSchema, B extends ObjectSchema, C extends ObjectSchema, D extends ObjectSchema>(A: Struct<ObjectType<A>, A>, B: Struct<ObjectType<B>, B>, C: Struct<ObjectType<C>, C>, D: Struct<ObjectType<D>, D>): Struct<ObjectType<Assign<Assign<Assign<A, B>, C>, D>>, Assign<Assign<Assign<A, B>, C>, D>>;
+export declare function assign<A extends ObjectSchema, B extends ObjectSchema, C extends ObjectSchema, D extends ObjectSchema, E extends ObjectSchema>(A: Struct<ObjectType<A>, A>, B: Struct<ObjectType<B>, B>, C: Struct<ObjectType<C>, C>, D: Struct<ObjectType<D>, D>, E: Struct<ObjectType<E>, E>): Struct<ObjectType<Assign<Assign<Assign<Assign<A, B>, C>, D>, E>>, Assign<Assign<Assign<Assign<A, B>, C>, D>, E>>;
+/**
+ * Define a new struct type with a custom validation function.
+ */
+export declare function define<T>(name: string, validator: Validator): Struct<T, null>;
+/**
+ * Create a new struct based on an existing struct, but the value is allowed to
+ * be `undefined`. `log` will be called if the value is not `undefined`.
+ */
+export declare function deprecated<T>(struct: Struct<T>, log: (value: unknown, ctx: Context) => void): Struct<T>;
+/**
+ * Create a struct with dynamic validation logic.
+ *
+ * The callback will receive the value currently being validated, and must
+ * return a struct object to validate it with. This can be useful to model
+ * validation logic that changes based on its input.
+ */
+export declare function dynamic<T>(fn: (value: unknown, ctx: Context) => Struct<T, any>): Struct<T, null>;
+/**
+ * Create a struct with lazily evaluated validation logic.
+ *
+ * The first time validation is run with the struct, the callback will be called
+ * and must return a struct object to use. This is useful for cases where you
+ * want to have self-referential structs for nested data structures to avoid a
+ * circular definition problem.
+ */
+export declare function lazy<T>(fn: () => Struct<T, any>): Struct<T, null>;
+/**
+ * Create a new struct based on an existing object struct, but excluding
+ * specific properties.
+ *
+ * Like TypeScript's `Omit` utility.
+ */
+export declare function omit<S extends ObjectSchema, K extends keyof S>(struct: Struct<ObjectType<S>, S>, keys: K[]): Struct<ObjectType<Omit<S, K>>, Omit<S, K>>;
+/**
+ * Create a new struct based on an existing object struct, but with all of its
+ * properties allowed to be `undefined`.
+ *
+ * Like TypeScript's `Partial` utility.
+ */
+export declare function partial<S extends ObjectSchema>(struct: Struct<ObjectType<S>, S> | S): Struct<ObjectType<PartialObjectSchema<S>>, PartialObjectSchema<S>>;
+/**
+ * Create a new struct based on an existing object struct, but only including
+ * specific properties.
+ *
+ * Like TypeScript's `Pick` utility.
+ */
+export declare function pick<S extends ObjectSchema, K extends keyof S>(struct: Struct<ObjectType<S>, S>, keys: K[]): Struct<ObjectType<Pick<S, K>>, Pick<S, K>>;
+/**
+ * Define a new struct type with a custom validation function.
+ *
+ * @deprecated This function has been renamed to `define`.
+ */
+export declare function struct<T>(name: string, validator: Validator): Struct<T, null>;
+//# sourceMappingURL=utilities.d.ts.map
diff --git a/dist/structs/utilities.d.mts b/dist/structs/utilities.d.mts
new file mode 100644
index 0000000000000000000000000000000000000000..64aed613911946f4b0f2f22f146924a2aef19188
--- /dev/null
+++ b/dist/structs/utilities.d.mts
@@ -0,0 +1,66 @@
+import { Struct, Context, Validator } from '../struct.mjs';
+import { ObjectSchema, Assign, ObjectType, PartialObjectSchema } from '../utils.mjs';
+/**
+ * Create a new struct that combines the properties properties from multiple
+ * object or type structs. Its return type will match the first parameter's type.
+ *
+ * Like JavaScript's `Object.assign` utility.
+ */
+export declare function assign<A extends ObjectSchema, B extends ObjectSchema>(A: Struct<ObjectType<A>, A>, B: Struct<ObjectType<B>, B>): Struct<ObjectType<Assign<A, B>>, Assign<A, B>>;
+export declare function assign<A extends ObjectSchema, B extends ObjectSchema, C extends ObjectSchema>(A: Struct<ObjectType<A>, A>, B: Struct<ObjectType<B>, B>, C: Struct<ObjectType<C>, C>): Struct<ObjectType<Assign<Assign<A, B>, C>>, Assign<Assign<A, B>, C>>;
+export declare function assign<A extends ObjectSchema, B extends ObjectSchema, C extends ObjectSchema, D extends ObjectSchema>(A: Struct<ObjectType<A>, A>, B: Struct<ObjectType<B>, B>, C: Struct<ObjectType<C>, C>, D: Struct<ObjectType<D>, D>): Struct<ObjectType<Assign<Assign<Assign<A, B>, C>, D>>, Assign<Assign<Assign<A, B>, C>, D>>;
+export declare function assign<A extends ObjectSchema, B extends ObjectSchema, C extends ObjectSchema, D extends ObjectSchema, E extends ObjectSchema>(A: Struct<ObjectType<A>, A>, B: Struct<ObjectType<B>, B>, C: Struct<ObjectType<C>, C>, D: Struct<ObjectType<D>, D>, E: Struct<ObjectType<E>, E>): Struct<ObjectType<Assign<Assign<Assign<Assign<A, B>, C>, D>, E>>, Assign<Assign<Assign<Assign<A, B>, C>, D>, E>>;
+/**
+ * Define a new struct type with a custom validation function.
+ */
+export declare function define<T>(name: string, validator: Validator): Struct<T, null>;
+/**
+ * Create a new struct based on an existing struct, but the value is allowed to
+ * be `undefined`. `log` will be called if the value is not `undefined`.
+ */
+export declare function deprecated<T>(struct: Struct<T>, log: (value: unknown, ctx: Context) => void): Struct<T>;
+/**
+ * Create a struct with dynamic validation logic.
+ *
+ * The callback will receive the value currently being validated, and must
+ * return a struct object to validate it with. This can be useful to model
+ * validation logic that changes based on its input.
+ */
+export declare function dynamic<T>(fn: (value: unknown, ctx: Context) => Struct<T, any>): Struct<T, null>;
+/**
+ * Create a struct with lazily evaluated validation logic.
+ *
+ * The first time validation is run with the struct, the callback will be called
+ * and must return a struct object to use. This is useful for cases where you
+ * want to have self-referential structs for nested data structures to avoid a
+ * circular definition problem.
+ */
+export declare function lazy<T>(fn: () => Struct<T, any>): Struct<T, null>;
+/**
+ * Create a new struct based on an existing object struct, but excluding
+ * specific properties.
+ *
+ * Like TypeScript's `Omit` utility.
+ */
+export declare function omit<S extends ObjectSchema, K extends keyof S>(struct: Struct<ObjectType<S>, S>, keys: K[]): Struct<ObjectType<Omit<S, K>>, Omit<S, K>>;
+/**
+ * Create a new struct based on an existing object struct, but with all of its
+ * properties allowed to be `undefined`.
+ *
+ * Like TypeScript's `Partial` utility.
+ */
+export declare function partial<S extends ObjectSchema>(struct: Struct<ObjectType<S>, S> | S): Struct<ObjectType<PartialObjectSchema<S>>, PartialObjectSchema<S>>;
+/**
+ * Create a new struct based on an existing object struct, but only including
+ * specific properties.
+ *
+ * Like TypeScript's `Pick` utility.
+ */
+export declare function pick<S extends ObjectSchema, K extends keyof S>(struct: Struct<ObjectType<S>, S>, keys: K[]): Struct<ObjectType<Pick<S, K>>, Pick<S, K>>;
+/**
+ * Define a new struct type with a custom validation function.
+ *
+ * @deprecated This function has been renamed to `define`.
+ */
+export declare function struct<T>(name: string, validator: Validator): Struct<T, null>;
+//# sourceMappingURL=utilities.d.ts.map
diff --git a/dist/structs/utilities.d.ts b/dist/structs/utilities.d.ts
deleted file mode 100644
index 3e3d53f50e2968996656921e1a0311f752e5d741..0000000000000000000000000000000000000000
--- a/dist/structs/utilities.d.ts
+++ /dev/null
@@ -1,66 +0,0 @@
-import { Struct, Context, Validator } from '../struct';
-import { ObjectSchema, Assign, ObjectType, PartialObjectSchema } from '../utils';
-/**
- * Create a new struct that combines the properties properties from multiple
- * object or type structs. Its return type will match the first parameter's type.
- *
- * Like JavaScript's `Object.assign` utility.
- */
-export declare function assign<A extends ObjectSchema, B extends ObjectSchema>(A: Struct<ObjectType<A>, A>, B: Struct<ObjectType<B>, B>): Struct<ObjectType<Assign<A, B>>, Assign<A, B>>;
-export declare function assign<A extends ObjectSchema, B extends ObjectSchema, C extends ObjectSchema>(A: Struct<ObjectType<A>, A>, B: Struct<ObjectType<B>, B>, C: Struct<ObjectType<C>, C>): Struct<ObjectType<Assign<Assign<A, B>, C>>, Assign<Assign<A, B>, C>>;
-export declare function assign<A extends ObjectSchema, B extends ObjectSchema, C extends ObjectSchema, D extends ObjectSchema>(A: Struct<ObjectType<A>, A>, B: Struct<ObjectType<B>, B>, C: Struct<ObjectType<C>, C>, D: Struct<ObjectType<D>, D>): Struct<ObjectType<Assign<Assign<Assign<A, B>, C>, D>>, Assign<Assign<Assign<A, B>, C>, D>>;
-export declare function assign<A extends ObjectSchema, B extends ObjectSchema, C extends ObjectSchema, D extends ObjectSchema, E extends ObjectSchema>(A: Struct<ObjectType<A>, A>, B: Struct<ObjectType<B>, B>, C: Struct<ObjectType<C>, C>, D: Struct<ObjectType<D>, D>, E: Struct<ObjectType<E>, E>): Struct<ObjectType<Assign<Assign<Assign<Assign<A, B>, C>, D>, E>>, Assign<Assign<Assign<Assign<A, B>, C>, D>, E>>;
-/**
- * Define a new struct type with a custom validation function.
- */
-export declare function define<T>(name: string, validator: Validator): Struct<T, null>;
-/**
- * Create a new struct based on an existing struct, but the value is allowed to
- * be `undefined`. `log` will be called if the value is not `undefined`.
- */
-export declare function deprecated<T>(struct: Struct<T>, log: (value: unknown, ctx: Context) => void): Struct<T>;
-/**
- * Create a struct with dynamic validation logic.
- *
- * The callback will receive the value currently being validated, and must
- * return a struct object to validate it with. This can be useful to model
- * validation logic that changes based on its input.
- */
-export declare function dynamic<T>(fn: (value: unknown, ctx: Context) => Struct<T, any>): Struct<T, null>;
-/**
- * Create a struct with lazily evaluated validation logic.
- *
- * The first time validation is run with the struct, the callback will be called
- * and must return a struct object to use. This is useful for cases where you
- * want to have self-referential structs for nested data structures to avoid a
- * circular definition problem.
- */
-export declare function lazy<T>(fn: () => Struct<T, any>): Struct<T, null>;
-/**
- * Create a new struct based on an existing object struct, but excluding
- * specific properties.
- *
- * Like TypeScript's `Omit` utility.
- */
-export declare function omit<S extends ObjectSchema, K extends keyof S>(struct: Struct<ObjectType<S>, S>, keys: K[]): Struct<ObjectType<Omit<S, K>>, Omit<S, K>>;
-/**
- * Create a new struct based on an existing object struct, but with all of its
- * properties allowed to be `undefined`.
- *
- * Like TypeScript's `Partial` utility.
- */
-export declare function partial<S extends ObjectSchema>(struct: Struct<ObjectType<S>, S> | S): Struct<ObjectType<PartialObjectSchema<S>>, PartialObjectSchema<S>>;
-/**
- * Create a new struct based on an existing object struct, but only including
- * specific properties.
- *
- * Like TypeScript's `Pick` utility.
- */
-export declare function pick<S extends ObjectSchema, K extends keyof S>(struct: Struct<ObjectType<S>, S>, keys: K[]): Struct<ObjectType<Pick<S, K>>, Pick<S, K>>;
-/**
- * Define a new struct type with a custom validation function.
- *
- * @deprecated This function has been renamed to `define`.
- */
-export declare function struct<T>(name: string, validator: Validator): Struct<T, null>;
-//# sourceMappingURL=utilities.d.ts.map
\ No newline at end of file
diff --git a/dist/utils.d.cts b/dist/utils.d.cts
new file mode 100644
index 0000000000000000000000000000000000000000..ef8cc4b8fa0af9633a0e3099d58ff76d3f690e3e
--- /dev/null
+++ b/dist/utils.d.cts
@@ -0,0 +1,140 @@
+import { Struct, Infer, Result, Context, Describe } from './struct.cjs';
+import { Failure } from './error.cjs';
+/**
+ * Check if a value is a plain object.
+ */
+export declare function isObject(x: unknown): x is object;
+/**
+ * Check if a value is a plain object.
+ */
+export declare function isPlainObject(x: unknown): x is {
+  [key: string]: any;
+};
+/**
+ * Return a value as a printable string.
+ */
+export declare function print(value: any): string;
+/**
+ * Shifts (removes and returns) the first value from the `input` iterator.
+ * Like `Array.prototype.shift()` but for an `Iterator`.
+ */
+export declare function shiftIterator<T>(input: Iterator<T>): T | undefined;
+/**
+ * Convert a single validation result to a failure.
+ */
+export declare function toFailure<T, S>(result: string | boolean | Partial<Failure>, context: Context, struct: Struct<T, S>, value: any): Failure | undefined;
+/**
+ * Convert a validation result to an iterable of failures.
+ */
+export declare function toFailures<T, S>(result: Result, context: Context, struct: Struct<T, S>, value: any): IterableIterator<Failure>;
+/**
+ * Check a value against a struct, traversing deeply into nested values, and
+ * returning an iterator of failures or success.
+ */
+export declare function run<T, S>(value: unknown, struct: Struct<T, S>, options?: {
+  path?: any[];
+  branch?: any[];
+  coerce?: boolean;
+  mask?: boolean;
+  message?: string;
+}): IterableIterator<[Failure, undefined] | [undefined, T]>;
+/**
+ * Convert a union of type to an intersection.
+ */
+export declare type UnionToIntersection<U> = (U extends any ? (arg: U) => any : never) extends (arg: infer I) => void ? I : never;
+/**
+ * Assign properties from one type to another, overwriting existing.
+ */
+export declare type Assign<T, U> = Simplify<U & Omit<T, keyof U>>;
+/**
+ * A schema for enum structs.
+ */
+export declare type EnumSchema<T extends string | number | undefined | null> = {
+  [K in NonNullable<T>]: K;
+};
+/**
+ * Check if a type is a match for another whilst treating overlapping
+ * unions as a match.
+ */
+export declare type IsMatch<T, G> = T extends G ? (G extends T ? T : never) : never;
+/**
+ * Check if a type is an exact match.
+ */
+export declare type IsExactMatch<T, U> = (<G>() => G extends T ? 1 : 2) extends <G>() => G extends U ? 1 : 2 ? T : never;
+/**
+ * Check if a type is a record type.
+ */
+export declare type IsRecord<T> = T extends object ? string extends keyof T ? T : never : never;
+/**
+ * Check if a type is a tuple.
+ */
+export declare type IsTuple<T> = T extends [any] ? T : T extends [any, any] ? T : T extends [any, any, any] ? T : T extends [any, any, any, any] ? T : T extends [any, any, any, any, any] ? T : never;
+/**
+ * Check if a type is a union.
+ */
+export declare type IsUnion<T, U extends T = T> = (T extends any ? (U extends T ? false : true) : false) extends false ? never : T;
+/**
+ * A schema for object structs.
+ */
+export declare type ObjectSchema = Record<string, Struct<any, any>>;
+/**
+ * Infer a type from an object struct schema.
+ */
+export declare type ObjectType<S extends ObjectSchema> = Simplify<Optionalize<{
+  [K in keyof S]: Infer<S[K]>;
+}>>;
+/**
+ * Omit properties from a type that extend from a specific type.
+ */
+export declare type OmitBy<T, V> = Omit<T, {
+  [K in keyof T]: V extends Extract<T[K], V> ? K : never;
+}[keyof T]>;
+/**
+ * Normalize properties of a type that allow `undefined` to make them optional.
+ */
+export declare type Optionalize<S extends object> = OmitBy<S, undefined> & Partial<PickBy<S, undefined>>;
+/**
+ * Transform an object schema type to represent a partial.
+ */
+export declare type PartialObjectSchema<S extends ObjectSchema> = {
+  [K in keyof S]: Struct<Infer<S[K]> | undefined>;
+};
+/**
+ * Pick properties from a type that extend from a specific type.
+ */
+export declare type PickBy<T, V> = Pick<T, {
+  [K in keyof T]: V extends Extract<T[K], V> ? K : never;
+}[keyof T]>;
+/**
+ * Simplifies a type definition to its most basic representation.
+ */
+export declare type Simplify<T> = T extends any[] | Date ? T : {
+  [K in keyof T]: T[K];
+} & {};
+export declare type If<B extends Boolean, Then, Else> = B extends true ? Then : Else;
+/**
+ * A schema for any type of struct.
+ */
+export declare type StructSchema<T> = [T] extends [string | undefined | null] ? [T] extends [IsMatch<T, string | undefined | null>] ? null : [T] extends [IsUnion<T>] ? EnumSchema<T> : T : [T] extends [number | undefined | null] ? [T] extends [IsMatch<T, number | undefined | null>] ? null : [T] extends [IsUnion<T>] ? EnumSchema<T> : T : [T] extends [boolean] ? [T] extends [IsExactMatch<T, boolean>] ? null : T : T extends bigint | symbol | undefined | null | Function | Date | Error | RegExp | Map<any, any> | WeakMap<any, any> | Set<any> | WeakSet<any> | Promise<any> ? null : T extends Array<infer E> ? T extends IsTuple<T> ? null : Struct<E> : T extends object ? T extends IsRecord<T> ? null : {
+  [K in keyof T]: Describe<T[K]>;
+} : null;
+/**
+ * A schema for tuple structs.
+ */
+export declare type TupleSchema<T> = {
+  [K in keyof T]: Struct<T[K]>;
+};
+/**
+ * Shorthand type for matching any `Struct`.
+ */
+export declare type AnyStruct = Struct<any, any>;
+/**
+ * Infer a tuple of types from a tuple of `Struct`s.
+ *
+ * This is used to recursively retrieve the type from `union` `intersection` and
+ * `tuple` structs.
+ */
+export declare type InferStructTuple<Tuple extends AnyStruct[], Length extends number = Tuple['length']> = Length extends Length ? number extends Length ? Tuple : _InferTuple<Tuple, Length, []> : never;
+declare type _InferTuple<Tuple extends AnyStruct[], Length extends number, Accumulated extends unknown[], Index extends number = Accumulated['length']> = Index extends Length ? Accumulated : _InferTuple<Tuple, Length, [...Accumulated, Infer<Tuple[Index]>]>;
+export {};
+//# sourceMappingURL=utils.d.ts.map
diff --git a/dist/utils.d.mts b/dist/utils.d.mts
new file mode 100644
index 0000000000000000000000000000000000000000..f82a4a271746369e5c3159d5d2d0d5237e925a1c
--- /dev/null
+++ b/dist/utils.d.mts
@@ -0,0 +1,140 @@
+import { Struct, Infer, Result, Context, Describe } from './struct.mjs';
+import { Failure } from './error.mjs';
+/**
+ * Check if a value is a plain object.
+ */
+export declare function isObject(x: unknown): x is object;
+/**
+ * Check if a value is a plain object.
+ */
+export declare function isPlainObject(x: unknown): x is {
+  [key: string]: any;
+};
+/**
+ * Return a value as a printable string.
+ */
+export declare function print(value: any): string;
+/**
+ * Shifts (removes and returns) the first value from the `input` iterator.
+ * Like `Array.prototype.shift()` but for an `Iterator`.
+ */
+export declare function shiftIterator<T>(input: Iterator<T>): T | undefined;
+/**
+ * Convert a single validation result to a failure.
+ */
+export declare function toFailure<T, S>(result: string | boolean | Partial<Failure>, context: Context, struct: Struct<T, S>, value: any): Failure | undefined;
+/**
+ * Convert a validation result to an iterable of failures.
+ */
+export declare function toFailures<T, S>(result: Result, context: Context, struct: Struct<T, S>, value: any): IterableIterator<Failure>;
+/**
+ * Check a value against a struct, traversing deeply into nested values, and
+ * returning an iterator of failures or success.
+ */
+export declare function run<T, S>(value: unknown, struct: Struct<T, S>, options?: {
+  path?: any[];
+  branch?: any[];
+  coerce?: boolean;
+  mask?: boolean;
+  message?: string;
+}): IterableIterator<[Failure, undefined] | [undefined, T]>;
+/**
+ * Convert a union of type to an intersection.
+ */
+export declare type UnionToIntersection<U> = (U extends any ? (arg: U) => any : never) extends (arg: infer I) => void ? I : never;
+/**
+ * Assign properties from one type to another, overwriting existing.
+ */
+export declare type Assign<T, U> = Simplify<U & Omit<T, keyof U>>;
+/**
+ * A schema for enum structs.
+ */
+export declare type EnumSchema<T extends string | number | undefined | null> = {
+  [K in NonNullable<T>]: K;
+};
+/**
+ * Check if a type is a match for another whilst treating overlapping
+ * unions as a match.
+ */
+export declare type IsMatch<T, G> = T extends G ? (G extends T ? T : never) : never;
+/**
+ * Check if a type is an exact match.
+ */
+export declare type IsExactMatch<T, U> = (<G>() => G extends T ? 1 : 2) extends <G>() => G extends U ? 1 : 2 ? T : never;
+/**
+ * Check if a type is a record type.
+ */
+export declare type IsRecord<T> = T extends object ? string extends keyof T ? T : never : never;
+/**
+ * Check if a type is a tuple.
+ */
+export declare type IsTuple<T> = T extends [any] ? T : T extends [any, any] ? T : T extends [any, any, any] ? T : T extends [any, any, any, any] ? T : T extends [any, any, any, any, any] ? T : never;
+/**
+ * Check if a type is a union.
+ */
+export declare type IsUnion<T, U extends T = T> = (T extends any ? (U extends T ? false : true) : false) extends false ? never : T;
+/**
+ * A schema for object structs.
+ */
+export declare type ObjectSchema = Record<string, Struct<any, any>>;
+/**
+ * Infer a type from an object struct schema.
+ */
+export declare type ObjectType<S extends ObjectSchema> = Simplify<Optionalize<{
+  [K in keyof S]: Infer<S[K]>;
+}>>;
+/**
+ * Omit properties from a type that extend from a specific type.
+ */
+export declare type OmitBy<T, V> = Omit<T, {
+  [K in keyof T]: V extends Extract<T[K], V> ? K : never;
+}[keyof T]>;
+/**
+ * Normalize properties of a type that allow `undefined` to make them optional.
+ */
+export declare type Optionalize<S extends object> = OmitBy<S, undefined> & Partial<PickBy<S, undefined>>;
+/**
+ * Transform an object schema type to represent a partial.
+ */
+export declare type PartialObjectSchema<S extends ObjectSchema> = {
+  [K in keyof S]: Struct<Infer<S[K]> | undefined>;
+};
+/**
+ * Pick properties from a type that extend from a specific type.
+ */
+export declare type PickBy<T, V> = Pick<T, {
+  [K in keyof T]: V extends Extract<T[K], V> ? K : never;
+}[keyof T]>;
+/**
+ * Simplifies a type definition to its most basic representation.
+ */
+export declare type Simplify<T> = T extends any[] | Date ? T : {
+  [K in keyof T]: T[K];
+} & {};
+export declare type If<B extends Boolean, Then, Else> = B extends true ? Then : Else;
+/**
+ * A schema for any type of struct.
+ */
+export declare type StructSchema<T> = [T] extends [string | undefined | null] ? [T] extends [IsMatch<T, string | undefined | null>] ? null : [T] extends [IsUnion<T>] ? EnumSchema<T> : T : [T] extends [number | undefined | null] ? [T] extends [IsMatch<T, number | undefined | null>] ? null : [T] extends [IsUnion<T>] ? EnumSchema<T> : T : [T] extends [boolean] ? [T] extends [IsExactMatch<T, boolean>] ? null : T : T extends bigint | symbol | undefined | null | Function | Date | Error | RegExp | Map<any, any> | WeakMap<any, any> | Set<any> | WeakSet<any> | Promise<any> ? null : T extends Array<infer E> ? T extends IsTuple<T> ? null : Struct<E> : T extends object ? T extends IsRecord<T> ? null : {
+  [K in keyof T]: Describe<T[K]>;
+} : null;
+/**
+ * A schema for tuple structs.
+ */
+export declare type TupleSchema<T> = {
+  [K in keyof T]: Struct<T[K]>;
+};
+/**
+ * Shorthand type for matching any `Struct`.
+ */
+export declare type AnyStruct = Struct<any, any>;
+/**
+ * Infer a tuple of types from a tuple of `Struct`s.
+ *
+ * This is used to recursively retrieve the type from `union` `intersection` and
+ * `tuple` structs.
+ */
+export declare type InferStructTuple<Tuple extends AnyStruct[], Length extends number = Tuple['length']> = Length extends Length ? number extends Length ? Tuple : _InferTuple<Tuple, Length, []> : never;
+declare type _InferTuple<Tuple extends AnyStruct[], Length extends number, Accumulated extends unknown[], Index extends number = Accumulated['length']> = Index extends Length ? Accumulated : _InferTuple<Tuple, Length, [...Accumulated, Infer<Tuple[Index]>]>;
+export {};
+//# sourceMappingURL=utils.d.ts.map
diff --git a/dist/utils.d.ts b/dist/utils.d.ts
deleted file mode 100644
index c463a3bb89972f7b29f82383ef03a2bbee183805..0000000000000000000000000000000000000000
--- a/dist/utils.d.ts
+++ /dev/null
@@ -1,140 +0,0 @@
-import { Struct, Infer, Result, Context, Describe } from './struct';
-import { Failure } from './error';
-/**
- * Check if a value is a plain object.
- */
-export declare function isObject(x: unknown): x is object;
-/**
- * Check if a value is a plain object.
- */
-export declare function isPlainObject(x: unknown): x is {
-    [key: string]: any;
-};
-/**
- * Return a value as a printable string.
- */
-export declare function print(value: any): string;
-/**
- * Shifts (removes and returns) the first value from the `input` iterator.
- * Like `Array.prototype.shift()` but for an `Iterator`.
- */
-export declare function shiftIterator<T>(input: Iterator<T>): T | undefined;
-/**
- * Convert a single validation result to a failure.
- */
-export declare function toFailure<T, S>(result: string | boolean | Partial<Failure>, context: Context, struct: Struct<T, S>, value: any): Failure | undefined;
-/**
- * Convert a validation result to an iterable of failures.
- */
-export declare function toFailures<T, S>(result: Result, context: Context, struct: Struct<T, S>, value: any): IterableIterator<Failure>;
-/**
- * Check a value against a struct, traversing deeply into nested values, and
- * returning an iterator of failures or success.
- */
-export declare function run<T, S>(value: unknown, struct: Struct<T, S>, options?: {
-    path?: any[];
-    branch?: any[];
-    coerce?: boolean;
-    mask?: boolean;
-    message?: string;
-}): IterableIterator<[Failure, undefined] | [undefined, T]>;
-/**
- * Convert a union of type to an intersection.
- */
-export declare type UnionToIntersection<U> = (U extends any ? (arg: U) => any : never) extends (arg: infer I) => void ? I : never;
-/**
- * Assign properties from one type to another, overwriting existing.
- */
-export declare type Assign<T, U> = Simplify<U & Omit<T, keyof U>>;
-/**
- * A schema for enum structs.
- */
-export declare type EnumSchema<T extends string | number | undefined | null> = {
-    [K in NonNullable<T>]: K;
-};
-/**
- * Check if a type is a match for another whilst treating overlapping
- * unions as a match.
- */
-export declare type IsMatch<T, G> = T extends G ? (G extends T ? T : never) : never;
-/**
- * Check if a type is an exact match.
- */
-export declare type IsExactMatch<T, U> = (<G>() => G extends T ? 1 : 2) extends <G>() => G extends U ? 1 : 2 ? T : never;
-/**
- * Check if a type is a record type.
- */
-export declare type IsRecord<T> = T extends object ? string extends keyof T ? T : never : never;
-/**
- * Check if a type is a tuple.
- */
-export declare type IsTuple<T> = T extends [any] ? T : T extends [any, any] ? T : T extends [any, any, any] ? T : T extends [any, any, any, any] ? T : T extends [any, any, any, any, any] ? T : never;
-/**
- * Check if a type is a union.
- */
-export declare type IsUnion<T, U extends T = T> = (T extends any ? (U extends T ? false : true) : false) extends false ? never : T;
-/**
- * A schema for object structs.
- */
-export declare type ObjectSchema = Record<string, Struct<any, any>>;
-/**
- * Infer a type from an object struct schema.
- */
-export declare type ObjectType<S extends ObjectSchema> = Simplify<Optionalize<{
-    [K in keyof S]: Infer<S[K]>;
-}>>;
-/**
- * Omit properties from a type that extend from a specific type.
- */
-export declare type OmitBy<T, V> = Omit<T, {
-    [K in keyof T]: V extends Extract<T[K], V> ? K : never;
-}[keyof T]>;
-/**
- * Normalize properties of a type that allow `undefined` to make them optional.
- */
-export declare type Optionalize<S extends object> = OmitBy<S, undefined> & Partial<PickBy<S, undefined>>;
-/**
- * Transform an object schema type to represent a partial.
- */
-export declare type PartialObjectSchema<S extends ObjectSchema> = {
-    [K in keyof S]: Struct<Infer<S[K]> | undefined>;
-};
-/**
- * Pick properties from a type that extend from a specific type.
- */
-export declare type PickBy<T, V> = Pick<T, {
-    [K in keyof T]: V extends Extract<T[K], V> ? K : never;
-}[keyof T]>;
-/**
- * Simplifies a type definition to its most basic representation.
- */
-export declare type Simplify<T> = T extends any[] | Date ? T : {
-    [K in keyof T]: T[K];
-} & {};
-export declare type If<B extends Boolean, Then, Else> = B extends true ? Then : Else;
-/**
- * A schema for any type of struct.
- */
-export declare type StructSchema<T> = [T] extends [string | undefined | null] ? [T] extends [IsMatch<T, string | undefined | null>] ? null : [T] extends [IsUnion<T>] ? EnumSchema<T> : T : [T] extends [number | undefined | null] ? [T] extends [IsMatch<T, number | undefined | null>] ? null : [T] extends [IsUnion<T>] ? EnumSchema<T> : T : [T] extends [boolean] ? [T] extends [IsExactMatch<T, boolean>] ? null : T : T extends bigint | symbol | undefined | null | Function | Date | Error | RegExp | Map<any, any> | WeakMap<any, any> | Set<any> | WeakSet<any> | Promise<any> ? null : T extends Array<infer E> ? T extends IsTuple<T> ? null : Struct<E> : T extends object ? T extends IsRecord<T> ? null : {
-    [K in keyof T]: Describe<T[K]>;
-} : null;
-/**
- * A schema for tuple structs.
- */
-export declare type TupleSchema<T> = {
-    [K in keyof T]: Struct<T[K]>;
-};
-/**
- * Shorthand type for matching any `Struct`.
- */
-export declare type AnyStruct = Struct<any, any>;
-/**
- * Infer a tuple of types from a tuple of `Struct`s.
- *
- * This is used to recursively retrieve the type from `union` `intersection` and
- * `tuple` structs.
- */
-export declare type InferStructTuple<Tuple extends AnyStruct[], Length extends number = Tuple['length']> = Length extends Length ? number extends Length ? Tuple : _InferTuple<Tuple, Length, []> : never;
-declare type _InferTuple<Tuple extends AnyStruct[], Length extends number, Accumulated extends unknown[], Index extends number = Accumulated['length']> = Index extends Length ? Accumulated : _InferTuple<Tuple, Length, [...Accumulated, Infer<Tuple[Index]>]>;
-export {};
-//# sourceMappingURL=utils.d.ts.map
\ No newline at end of file
diff --git a/package.json b/package.json
index 84598ac6614c87e08a88985b57303b5f3a87c1a4..d5a3a240fee9bf3857da3dc61dca8f786c6d026c 100644
--- a/package.json
+++ b/package.json
@@ -8,6 +8,18 @@
   "main": "./dist/index.cjs",
   "module": "./dist/index.mjs",
   "types": "./dist/index.d.ts",
+  "exports": {
+    ".": {
+      "import": {
+        "types": "./dist/index.d.mts",
+        "default": "./dist/index.mjs"
+      },
+      "require": {
+        "types": "./dist/index.d.cts",
+        "default": "./dist/index.cjs"
+      }
+    }
+  },
   "sideEffects": false,
   "files": [
     "dist"
